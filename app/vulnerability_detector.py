import re

class VulnerabilityDetector:
    def __init__(self, contract_code):
        self.contract_code = contract_code

    def detect_vulnerabilities(self):
        vulnerabilities = []

        # 检测重入漏洞
        reentrancy_pattern = r"msg\.sender\.call\.value\("
        reentrancy_matches = re.finditer(reentrancy_pattern, self.contract_code)
        for match in reentrancy_matches:
            line_number = self.get_line_number(match.start())
            vulnerabilities.append({
                'type': 'Reentrancy',
                'location': f'Line {line_number}',
                'description': 'Potential reentrancy vulnerability detected.'
            })

        # 检测时间戳依赖
        timestamp_dependency_pattern = r"block\.timestamp"
        timestamp_dependency_matches = re.finditer(timestamp_dependency_pattern, self.contract_code)
        require_pattern = r"require\s*\("
        for match in timestamp_dependency_matches:
            line_number = self.get_line_number(match.start())
            # 检查是否在 require 语句内
            if self.is_inside_require(match.start(), require_pattern):
                vulnerabilities.append({
                    'type': 'Timestamp Dependency',
                    'location': f'Line {line_number}',
                    'description': 'Potential timestamp dependency vulnerability detected.'
                })

        # 检测整型溢出
        integer_overflow_pattern = r"(?<![_\w])uint\d*\s+.*?\s*[\-+]"
        integer_overflow_matches = re.finditer(integer_overflow_pattern, self.contract_code)
        for match in integer_overflow_matches:
            line_number = self.get_line_number(match.start())
            vulnerabilities.append({
                'type': 'Integer Overflow',
                'location': f'Line {line_number}',
                'description': 'Potential integer overflow vulnerability detected.'
            })

        # 检测未使用的变量
        unused_variable_pattern = r"var\s+\w+\s*;"
        unused_variable_matches = re.finditer(unused_variable_pattern, self.contract_code)
        for match in unused_variable_matches:
            line_number = self.get_line_number(match.start())
            vulnerabilities.append({
                'type': 'Unused Variable',
                'location': f'Line {line_number}',
                'description': 'Potential unused variable detected.'
            })

        # 检测未保护的函数
        unprotected_function_pattern = r"function\s+\w+\s*\("
        public_function_pattern = r"public\s+"
        unprotected_function_matches = re.finditer(unprotected_function_pattern, self.contract_code)
        for match in unprotected_function_matches:
            line_number = self.get_line_number(match.start())
            if not self.is_protected_function(match.start(), public_function_pattern):
                vulnerabilities.append({
                    'type': 'Unprotected Function',
                    'location': f'Line {line_number}',
                    'description': 'Public function without access control detected.'
                })

        return vulnerabilities

    def get_line_number(self, index):
        return self.contract_code.count('\n', 0, index) + 1

    def is_inside_require(self, start_index, require_pattern):
        previous_line = self.contract_code.rfind('\n', 0, start_index) + 1
        next_line = self.contract_code.find('\n', start_index)
        require_block = self.contract_code[previous_line:next_line]
        return re.search(require_pattern, require_block) is not None

    def is_protected_function(self, start_index, public_function_pattern):
        previous_line = self.contract_code.rfind('\n', 0, start_index) + 1
        next_line = self.contract_code.find('\n', start_index)
        function_declaration = self.contract_code[previous_line:next_line]
        return re.search(public_function_pattern, function_declaration) is not None

# 示例用法
if __name__ == "__main__":
    contract_source_code = """
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    contract Example {
        function withdraw(uint _amount) public payable {
            msg.sender.call.value(_amount)("");
        }
    }
    """
    detector = VulnerabilityDetector(contract_source_code)
    vulnerabilities = detector.detect_vulnerabilities()
    for issue in vulnerabilities:
        print(issue)
